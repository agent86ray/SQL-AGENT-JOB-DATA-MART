/*
Deployment script for SQL_AGENT_DATA_MART

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "SQL_AGENT_DATA_MART"
:setvar DefaultFilePrefix "SQL_AGENT_DATA_MART"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
PRINT N'Creating [staging]...';


GO
CREATE SCHEMA [staging]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [staging].[sysjobs_UPDATE]...';


GO
CREATE TABLE [staging].[sysjobs_UPDATE] (
    [ETL_KEY]     INT              NOT NULL,
    [STAGING_KEY] INT              NOT NULL,
    [ACTION]      CHAR (1)         NOT NULL,
    [job_id]      UNIQUEIDENTIFIER NOT NULL,
    [JOB_KEY]     INT              NULL,
    [NEW_JOB_KEY] INT              NOT NULL
);


GO
PRINT N'Creating [staging].[sysjobactivity]...';


GO
CREATE TABLE [staging].[sysjobactivity] (
    [session_id]              INT              NOT NULL,
    [job_id]                  UNIQUEIDENTIFIER NOT NULL,
    [run_requested_date]      DATETIME         NULL,
    [run_requested_source]    [sysname]        NULL,
    [queued_date]             DATETIME         NULL,
    [start_execution_date]    DATETIME         NULL,
    [last_executed_step_id]   INT              NULL,
    [last_executed_step_date] DATETIME         NULL,
    [stop_execution_date]     DATETIME         NULL,
    [job_history_id]          INT              NULL,
    [next_scheduled_run_date] DATETIME         NULL,
    [ETL_KEY]                 INT              NOT NULL,
    [STAGING_KEY]             INT              IDENTITY (1, 1) NOT NULL
);


GO
PRINT N'Creating [staging].[sysjobhistory]...';


GO
CREATE TABLE [staging].[sysjobhistory] (
    [instance_id]         INT              NOT NULL,
    [job_id]              UNIQUEIDENTIFIER NOT NULL,
    [step_id]             INT              NOT NULL,
    [step_name]           [sysname]        NOT NULL,
    [sql_message_id]      INT              NOT NULL,
    [sql_severity]        INT              NOT NULL,
    [message]             NVARCHAR (4000)  NULL,
    [run_status]          INT              NOT NULL,
    [run_date]            INT              NOT NULL,
    [run_time]            INT              NOT NULL,
    [run_duration]        INT              NOT NULL,
    [operator_id_emailed] INT              NOT NULL,
    [operator_id_netsent] INT              NOT NULL,
    [operator_id_paged]   INT              NOT NULL,
    [retries_attempted]   INT              NOT NULL,
    [server]              [sysname]        NOT NULL,
    [start_time]          DATETIME         NOT NULL,
    [end_time]            DATETIME         NOT NULL,
    [duration_seconds]    INT              NULL,
    [ETL_KEY]             INT              NOT NULL,
    [STAGING_KEY]         INT              IDENTITY (1, 1) NOT NULL
);


GO
PRINT N'Creating [staging].[sysjobsteps]...';


GO
CREATE TABLE [staging].[sysjobsteps] (
    [job_id]                UNIQUEIDENTIFIER NOT NULL,
    [step_id]               INT              NOT NULL,
    [step_name]             [sysname]        NOT NULL,
    [subsystem]             NVARCHAR (40)    NOT NULL,
    [command]               NVARCHAR (MAX)   NULL,
    [flags]                 INT              NOT NULL,
    [additional_parameters] NVARCHAR (MAX)   NULL,
    [cmdexec_success_code]  INT              NOT NULL,
    [on_success_action]     TINYINT          NOT NULL,
    [on_success_step_id]    INT              NOT NULL,
    [on_fail_action]        TINYINT          NOT NULL,
    [on_fail_step_id]       INT              NOT NULL,
    [server]                [sysname]        NULL,
    [database_name]         [sysname]        NULL,
    [database_user_name]    [sysname]        NULL,
    [retry_attempts]        INT              NOT NULL,
    [retry_interval]        INT              NOT NULL,
    [os_run_priority]       INT              NOT NULL,
    [output_file_name]      NVARCHAR (200)   NULL,
    [last_run_outcome]      INT              NOT NULL,
    [last_run_duration]     INT              NOT NULL,
    [last_run_retries]      INT              NOT NULL,
    [last_run_date]         INT              NOT NULL,
    [last_run_time]         INT              NOT NULL,
    [proxy_id]              INT              NULL,
    [step_uid]              UNIQUEIDENTIFIER NULL,
    [ETL_KEY]               INT              NOT NULL,
    [STAGING_KEY]           INT              IDENTITY (1, 1) NOT NULL
);


GO
PRINT N'Creating [staging].[sysjobs]...';


GO
CREATE TABLE [staging].[sysjobs] (
    [job_id]                     UNIQUEIDENTIFIER NOT NULL,
    [originating_server_id]      INT              NOT NULL,
    [name]                       [sysname]        NOT NULL,
    [enabled]                    TINYINT          NOT NULL,
    [description]                NVARCHAR (512)   NULL,
    [start_step_id]              INT              NOT NULL,
    [category_id]                INT              NOT NULL,
    [owner_sid]                  VARBINARY (85)   NOT NULL,
    [notify_level_eventlog]      INT              NOT NULL,
    [notify_level_email]         INT              NOT NULL,
    [notify_level_netsend]       INT              NOT NULL,
    [notify_level_page]          INT              NOT NULL,
    [notify_email_operator_id]   INT              NOT NULL,
    [notify_netsend_operator_id] INT              NOT NULL,
    [notify_page_operator_id]    INT              NOT NULL,
    [delete_level]               INT              NOT NULL,
    [date_created]               DATETIME         NOT NULL,
    [date_modified]              DATETIME         NOT NULL,
    [version_number]             INT              NOT NULL,
    [ETL_KEY]                    INT              NOT NULL,
    [STAGING_KEY]                INT              IDENTITY (1, 1) NOT NULL
);


GO
PRINT N'Creating [dbo].[ACTIVE_JOBS]...';


GO
CREATE TABLE [dbo].[ACTIVE_JOBS] (
    [REFRESH_KEY]          INT              NOT NULL,
    [job_id]               UNIQUEIDENTIFIER NOT NULL,
    [CURRENT_DURATION]     INT              NULL,
    [EXECUTION_COUNT]      INT              NULL,
    [AVERAGE_DURATION]     INT              NULL,
    [ESTIMATED_COMPLETION] SMALLDATETIME    NULL,
    CONSTRAINT [PK_ACTIVE_JOBS] PRIMARY KEY CLUSTERED ([REFRESH_KEY] ASC, [job_id] ASC)
);


GO
PRINT N'Creating [dbo].[ACTIVE_JOBS_REFRESH]...';


GO
CREATE TABLE [dbo].[ACTIVE_JOBS_REFRESH] (
    [REFRESH_KEY]  INT           NOT NULL,
    [REFRESH_DATE] SMALLDATETIME NULL,
    CONSTRAINT [PK_ACTIVE_JOBS_REFRESH] PRIMARY KEY CLUSTERED ([REFRESH_KEY] ASC)
);


GO
PRINT N'Creating [dbo].[ETL_DIMENSION_LOG]...';


GO
CREATE TABLE [dbo].[ETL_DIMENSION_LOG] (
    [ETL_KEY]     INT           IDENTITY (1, 1) NOT NULL,
    [START_DATE]  SMALLDATETIME NOT NULL,
    [END_DATE]    SMALLDATETIME NULL,
    [RESULT_CODE] INT           NULL,
    CONSTRAINT [PK_ETL_DIMENSION_LOG] PRIMARY KEY CLUSTERED ([ETL_KEY] ASC)
);


GO
PRINT N'Creating [dbo].[ETL_HISTORY_LOG]...';


GO
CREATE TABLE [dbo].[ETL_HISTORY_LOG] (
    [ETL_KEY]           INT           IDENTITY (1, 1) NOT NULL,
    [START_DATE]        SMALLDATETIME NOT NULL,
    [BEGIN_INSTANCE_ID] INT           NOT NULL,
    [END_INSTANCE_ID]   INT           NOT NULL,
    [END_DATE]          SMALLDATETIME NULL,
    [RESULT_CODE]       INT           NULL,
    CONSTRAINT [PK_ETL_HISTORY_LOG] PRIMARY KEY CLUSTERED ([ETL_KEY] ASC)
);


GO
PRINT N'Creating [dbo].[JOB_CURRENT]...';


GO
CREATE TABLE [dbo].[JOB_CURRENT] (
    [JOB_KEY]        INT              NOT NULL,
    [job_id]         UNIQUEIDENTIFIER NOT NULL,
    [JOB_STEP_COUNT] INT              NOT NULL,
    CONSTRAINT [PK_JOB_CURRENT] PRIMARY KEY CLUSTERED ([JOB_KEY] ASC)
);


GO
PRINT N'Creating [dbo].[JOB_EXCLUDE]...';


GO
CREATE TABLE [dbo].[JOB_EXCLUDE] (
    [job_id] UNIQUEIDENTIFIER NOT NULL,
    [name]   [sysname]        NOT NULL
);


GO
PRINT N'Creating [dbo].[JOB_INSTANCE]...';


GO
CREATE TABLE [dbo].[JOB_INSTANCE] (
    [JOB_KEY]             INT              NOT NULL,
    [INSTANCE_ID]         INT              NOT NULL,
    [job_id]              UNIQUEIDENTIFIER NOT NULL,
    [step_id]             INT              NOT NULL,
    [step_name]           [sysname]        NOT NULL,
    [sql_message_id]      INT              NOT NULL,
    [sql_severity]        INT              NOT NULL,
    [message]             NVARCHAR (4000)  NULL,
    [run_status]          INT              NOT NULL,
    [run_date]            INT              NOT NULL,
    [run_time]            INT              NOT NULL,
    [run_duration]        INT              NOT NULL,
    [operator_id_emailed] INT              NOT NULL,
    [operator_id_netsent] INT              NOT NULL,
    [operator_id_paged]   INT              NOT NULL,
    [retries_attempted]   INT              NOT NULL,
    [server]              [sysname]        NOT NULL,
    [start_time]          DATETIME         NOT NULL,
    [end_time]            DATETIME         NOT NULL,
    [duration_seconds]    INT              NULL,
    [ETL_KEY]             INT              NOT NULL,
    [STAGING_KEY]         INT              NOT NULL
);


GO
PRINT N'Creating [dbo].[JOB_INSTANCE_ALL_STEPS_COMPLETED]...';


GO
CREATE TABLE [dbo].[JOB_INSTANCE_ALL_STEPS_COMPLETED] (
    [JOB_KEY]     INT NOT NULL,
    [INSTANCE_ID] INT NOT NULL
);


GO
PRINT N'Creating [dbo].[JOB_STEP_AVERAGE_DURATION]...';


GO
CREATE TABLE [dbo].[JOB_STEP_AVERAGE_DURATION] (
    [JOB_KEY]               INT NOT NULL,
    [step_id]               INT NOT NULL,
    [TOTAL_STEP_COUNT]      INT NULL,
    [TOTAL_STEP_DURATION]   INT NULL,
    [AVERAGE_STEP_DURATION] INT NULL,
    CONSTRAINT [PK_JOB_STEP_AVERAGE_DURATION] PRIMARY KEY CLUSTERED ([JOB_KEY] ASC, [step_id] ASC)
);


GO
PRINT N'Creating [dbo].[JOB_STEP_AVERAGE_DURATION_UPDATE]...';


GO
CREATE TABLE [dbo].[JOB_STEP_AVERAGE_DURATION_UPDATE] (
    [JOB_KEY]               INT NOT NULL,
    [step_id]               INT NOT NULL,
    [TOTAL_STEP_COUNT]      INT NULL,
    [TOTAL_STEP_DURATION]   INT NULL,
    [AVERAGE_STEP_DURATION] INT NULL
);


GO
PRINT N'Creating [dbo].[JOB_STEP_DURATION]...';


GO
CREATE TABLE [dbo].[JOB_STEP_DURATION] (
    [JOB_KEY]                INT NOT NULL,
    [step_id]                INT NOT NULL,
    [JOB_STEP_COUNT]         INT NULL,
    [JOB_STEP_TOTAL_SECONDS] INT NULL
);


GO
PRINT N'Creating [dbo].[JOB_STEP_INSTANCE]...';


GO
CREATE TABLE [dbo].[JOB_STEP_INSTANCE] (
    [JOB_KEY]              INT              NOT NULL,
    [JOB_INSTANCE_ID]      INT              NOT NULL,
    [JOB_STEP_INSTANCE_ID] INT              NOT NULL,
    [job_id]               UNIQUEIDENTIFIER NOT NULL,
    [step_id]              INT              NOT NULL,
    [step_name]            [sysname]        NOT NULL,
    [sql_message_id]       INT              NOT NULL,
    [sql_severity]         INT              NOT NULL,
    [message]              NVARCHAR (4000)  NULL,
    [run_status]           INT              NOT NULL,
    [run_date]             INT              NOT NULL,
    [run_time]             INT              NOT NULL,
    [run_duration]         INT              NOT NULL,
    [operator_id_emailed]  INT              NOT NULL,
    [operator_id_netsent]  INT              NOT NULL,
    [operator_id_paged]    INT              NOT NULL,
    [retries_attempted]    INT              NOT NULL,
    [server]               [sysname]        NOT NULL,
    [start_time]           DATETIME         NOT NULL,
    [end_time]             DATETIME         NOT NULL,
    [duration_seconds]     INT              NULL,
    [ETL_KEY]              INT              NOT NULL,
    [STAGING_KEY]          INT              NOT NULL
);


GO
PRINT N'Creating [dbo].[sysjobs]...';


GO
CREATE TABLE [dbo].[sysjobs] (
    [JOB_KEY]                    INT              NOT NULL,
    [job_id]                     UNIQUEIDENTIFIER NOT NULL,
    [originating_server_id]      INT              NOT NULL,
    [name]                       [sysname]        NOT NULL,
    [enabled]                    TINYINT          NOT NULL,
    [description]                NVARCHAR (512)   NULL,
    [start_step_id]              INT              NOT NULL,
    [category_id]                INT              NOT NULL,
    [owner_sid]                  VARBINARY (85)   NOT NULL,
    [notify_level_eventlog]      INT              NOT NULL,
    [notify_level_email]         INT              NOT NULL,
    [notify_level_netsend]       INT              NOT NULL,
    [notify_level_page]          INT              NOT NULL,
    [notify_email_operator_id]   INT              NOT NULL,
    [notify_netsend_operator_id] INT              NOT NULL,
    [notify_page_operator_id]    INT              NOT NULL,
    [delete_level]               INT              NOT NULL,
    [date_created]               DATETIME         NOT NULL,
    [date_modified]              DATETIME         NOT NULL,
    [version_number]             INT              NOT NULL,
    [ETL_KEY]                    INT              NOT NULL,
    [STAGING_KEY]                INT              NOT NULL
);


GO
PRINT N'Creating [dbo].[sysjobsteps]...';


GO
CREATE TABLE [dbo].[sysjobsteps] (
    [JOB_KEY]               INT              NOT NULL,
    [job_id]                UNIQUEIDENTIFIER NOT NULL,
    [step_id]               INT              NOT NULL,
    [step_name]             [sysname]        NOT NULL,
    [subsystem]             NVARCHAR (40)    NOT NULL,
    [command]               NVARCHAR (MAX)   NULL,
    [flags]                 INT              NOT NULL,
    [additional_parameters] NVARCHAR (MAX)   NULL,
    [cmdexec_success_code]  INT              NOT NULL,
    [on_success_action]     TINYINT          NOT NULL,
    [on_success_step_id]    INT              NOT NULL,
    [on_fail_action]        TINYINT          NOT NULL,
    [on_fail_step_id]       INT              NOT NULL,
    [server]                [sysname]        NULL,
    [database_name]         [sysname]        NULL,
    [database_user_name]    [sysname]        NULL,
    [retry_attempts]        INT              NOT NULL,
    [retry_interval]        INT              NOT NULL,
    [os_run_priority]       INT              NOT NULL,
    [output_file_name]      NVARCHAR (200)   NULL,
    [last_run_outcome]      INT              NOT NULL,
    [last_run_duration]     INT              NOT NULL,
    [last_run_retries]      INT              NOT NULL,
    [last_run_date]         INT              NOT NULL,
    [last_run_time]         INT              NOT NULL,
    [proxy_id]              INT              NULL,
    [step_uid]              UNIQUEIDENTIFIER NULL,
    [ETL_KEY]               INT              NOT NULL,
    [STAGING_KEY]           INT              NOT NULL
);


GO
PRINT N'Creating [dbo].[DF_ETL_DIMENSION_LOG_START_DATE]...';


GO
ALTER TABLE [dbo].[ETL_DIMENSION_LOG]
    ADD CONSTRAINT [DF_ETL_DIMENSION_LOG_START_DATE] DEFAULT GETDATE() FOR [START_DATE];


GO
PRINT N'Creating [dbo].[DF_ETL_HISTORY_START_DATE]...';


GO
ALTER TABLE [dbo].[ETL_HISTORY_LOG]
    ADD CONSTRAINT [DF_ETL_HISTORY_START_DATE] DEFAULT GETDATE() FOR [START_DATE];


GO
PRINT N'Creating [dbo].[ETL_KEY]...';


GO
CREATE SEQUENCE [dbo].[ETL_KEY]
    AS INT
    START WITH 1
    INCREMENT BY 1;


GO
PRINT N'Creating [dbo].[JOB_KEY]...';


GO
CREATE SEQUENCE [dbo].[JOB_KEY]
    AS INT
    START WITH 1
    INCREMENT BY 1;


GO
PRINT N'Creating [dbo].[REFRESH_KEY]...';


GO
CREATE SEQUENCE [dbo].[REFRESH_KEY]
    AS INT
    START WITH 1
    INCREMENT BY 1;


GO
PRINT N'Creating [staging].[CK_sysjobs_UPDATE_ACTION]...';


GO
ALTER TABLE [staging].[sysjobs_UPDATE] WITH NOCHECK
    ADD CONSTRAINT [CK_sysjobs_UPDATE_ACTION] CHECK ([ACTION] IN ( 'I', 'U', 'D'));


GO
PRINT N'Creating [dbo].[vACTIVE_JOBS]...';


GO
CREATE VIEW [dbo].[vACTIVE_JOBS]
AS
	SELECT 
		[REFRESH_KEY]
	,	COALESCE(j.[name], CONVERT(NVARCHAR(128), a.[job_id])) AS [JobName]
	,	[CURRENT_DURATION]
	,	[EXECUTION_COUNT]
	,	[AVERAGE_DURATION]
	,	[ESTIMATED_COMPLETION]
	FROM [dbo].[ACTIVE_JOBS] a
	JOIN [dbo].[JOB_CURRENT] c 
	ON c.[job_id] = a.[job_id]
	JOIN [dbo].[sysjobs] j
	ON j.[JOB_KEY] = c.[JOB_KEY]
	WHERE [REFRESH_KEY] = (
		SELECT 
			MAX([REFRESH_KEY])
		FROM [dbo].[ACTIVE_JOBS_REFRESH]
	);
GO
PRINT N'Creating [dbo].[vJOB_CURRENT]...';


GO
CREATE VIEW [dbo].[vJOB_CURRENT]
AS
	SELECT 
		c.[JOB_KEY]
	,	j.[name]
	,	c.[job_id]
	,	c.[JOB_STEP_COUNT]
	,	j.date_modified
	FROM [dbo].[JOB_CURRENT] c
	JOIN [dbo].[sysjobs] j
	ON j.[JOB_KEY] = c.[JOB_KEY]
	LEFT JOIN [dbo].[JOB_EXCLUDE] x
	ON x.[job_id] = j.[job_id]
	WHERE x.[name] IS NULL;
GO
PRINT N'Creating [staging].[vsysjobhistory]...';


GO
CREATE VIEW [staging].[vsysjobhistory]
AS 
	WITH CTE_EXCLUDE_JOBS AS (
		SELECT [job_id]
		FROM [msdb].[dbo].[sysjobs]
		WHERE [name] IN (
			'PROCESS SQL AGENT DATA MART DIMENSIONS'
		,	'PROCESS SQL AGENT DATA MART HISTORY'
		,	'PROCESS SQL AGENT DATA MART ACTIVITY'
		)
	)

	SELECT 
		c.[JOB_KEY]
	,	c.[name]
	,	c.[JOB_STEP_COUNT]
	,	h.[instance_id]
	,	h.[job_id]
	,	h.[step_id]
	,	h.[start_time]
	,	h.[end_time]
	,	h.[duration_seconds]
	,	IIF(x.[job_id] IS NULL, 'Y', 'N') AS [INCLUDE]
	FROM [staging].[sysjobhistory] h
	JOIN [dbo].[vJOB_CURRENT] c
	ON c.[job_id] = h.[job_id]
	LEFT JOIN CTE_EXCLUDE_JOBS x
	ON x.[job_id] = h.[job_id]
	WHERE x.[job_id] IS NULL;
GO
PRINT N'Creating [staging].[STAGE_sysjobs_UPDATE]...';


GO
CREATE PROCEDURE [staging].[STAGE_sysjobs_UPDATE]
AS
BEGIN
	/*
		Compare each job_id in the [staging].[sysjobs] table with the latest job_id row in the [dbo].[sysjobs] table 
		and determine if it should be inserted or updated in the [dbo].[sysjobs] table. It could also be no change.
	*/

	TRUNCATE TABLE [staging].[sysjobs_UPDATE];

	;WITH CTE_sysjobs AS (
		SELECT
			s.[ETL_KEY]
		,	s.[STAGING_KEY]
		,	CASE
				WHEN d.[job_id] IS NULL THEN 'I'	-- new job
				WHEN d.[job_id] IS NOT NULL AND s.[date_modified] > d.[date_modified] THEN 'U'
			END [Action]
		,	d.[JOB_KEY]
		,	s.[job_id]
		FROM [staging].[sysjobs] s
		LEFT JOIN[dbo].[vJOB_CURRENT] d
		ON d.[job_id] = s.[job_id]
		-- EXCLUDE jobs
		LEFT JOIN [dbo].[JOB_EXCLUDE] x
		ON x.[job_id] = s.[job_id]
		WHERE x.[name] IS NULL
	)

	INSERT [staging].[sysjobs_UPDATE] (
		[ETL_KEY]
	,	[STAGING_KEY]
	,	[ACTION]
	,	[job_id]
	,	[JOB_KEY]
	,	[NEW_JOB_KEY]
	)
	SELECT
		[ETL_KEY]
	,	[STAGING_KEY]
	,	[ACTION]
	,	[job_id]
	,	[JOB_KEY]		-- NULL if insert
	,	NEXT VALUE FOR [dbo].[JOB_KEY]
	FROM CTE_sysjobs
	WHERE [Action] IN ('I', 'U');
END
GO
PRINT N'Creating [dbo].[ACCUMULATE_JOB_STEP_DURATION]...';


GO
CREATE PROCEDURE [dbo].[ACCUMULATE_JOB_STEP_DURATION]
	@BEGIN_JOB_INSTANCE INT
,	@END_JOB_INSTANCE	INT
AS
BEGIN
	/*
		Accumulate the duration for jobs with a [JOB_INSTANCE_ID] in the range of @BEGIN_JOB_INSTANCE
		and @END_JOB_INSTANCE.
	*/

	;WITH CTE_JOB_STEPS AS (
		SELECT 
			j.[JOB_KEY]
		,	j.[JOB_INSTANCE_ID]
		,	j.[step_id]
		,	j.[duration_seconds]
		FROM [dbo].[JOB_STEP_INSTANCE] j
		WHERE j.[JOB_INSTANCE_ID] BETWEEN @BEGIN_JOB_INSTANCE AND @END_JOB_INSTANCE
	)

	, CTE_SUM_STEPS AS (
		SELECT
			[JOB_KEY]
		,	[step_id]
		,	COUNT(*)				AS [JOB_STEP_COUNT]
		,	SUM([duration_seconds])	AS [JOB_STEP_TOTAL_SECONDS]
		FROM CTE_JOB_STEPS
		GROUP BY [JOB_KEY], [step_id]
	)

	INSERT [dbo].[JOB_STEP_DURATION] (
		[JOB_KEY]					
	,	[step_id]					
	,	[JOB_STEP_COUNT]			
	,	[JOB_STEP_TOTAL_SECONDS]
	)
	SELECT
		[JOB_KEY]					
	,	[step_id]					
	,	[JOB_STEP_COUNT]			
	,	[JOB_STEP_TOTAL_SECONDS]
	FROM CTE_SUM_STEPS;
END
GO
PRINT N'Creating [dbo].[CALCULATE_JOB_STEP_AVERAGE_DURATION]...';


GO
CREATE PROCEDURE [dbo].[CALCULATE_JOB_STEP_AVERAGE_DURATION]
	@BEGIN_JOB_INSTANCE INT
,	@END_JOB_INSTANCE	INT
AS
BEGIN
	/*
		Calculate the average duration for the job steps based on the @BEGIN_JOB_INSTANCE 
		and @END_JOB_INSTANCE range.
	*/

	TRUNCATE TABLE [dbo].[JOB_STEP_AVERAGE_DURATION_UPDATE];

	;WITH CTE_JOBS AS (
		SELECT DISTINCT
			[JOB_KEY]
		FROM [dbo].[JOB_STEP_INSTANCE]
		WHERE [JOB_STEP_INSTANCE_ID] BETWEEN @BEGIN_JOB_INSTANCE AND @END_JOB_INSTANCE
	)
	
	, CTE_SUM_DURATION AS (
		SELECT 
			d.[JOB_KEY]					
		,	d.[step_id]					
		,	SUM(d.[JOB_STEP_COUNT])			[TOTAL_STEP_COUNT]
		,	SUM(d.[JOB_STEP_TOTAL_SECONDS])	[TOTAL_STEP_DURATION]
		FROM [dbo].[JOB_STEP_DURATION] d
		JOIN CTE_JOBS j
		ON j.[JOB_KEY] = d.[JOB_KEY]
		GROUP BY d.[JOB_KEY], d.[step_id]
	)

	, CTE_AVG_DURATION AS (
		SELECT
			[JOB_KEY]					
		,	[step_id]					
		,	[TOTAL_STEP_COUNT]
		,	[TOTAL_STEP_DURATION]
		,	IIF(ISNULL([TOTAL_STEP_COUNT], 0) > 0
			,	[TOTAL_STEP_DURATION] / [TOTAL_STEP_COUNT]
			,	NULL
			)	AS [AVERAGE_STEP_DURATION]
		FROM CTE_SUM_DURATION	
	)

	INSERT [dbo].[JOB_STEP_AVERAGE_DURATION_UPDATE] (
		[JOB_KEY]					
	,	[step_id]					
	,	[TOTAL_STEP_COUNT]			
	,	[TOTAL_STEP_DURATION]		
	,	[AVERAGE_STEP_DURATION]		
	)

	SELECT
		[JOB_KEY]					
	,	[step_id]					
	,	[TOTAL_STEP_COUNT]			
	,	[TOTAL_STEP_DURATION]		
	,	[AVERAGE_STEP_DURATION]		
	FROM CTE_AVG_DURATION;

	-- update existing average durations
	UPDATE d
	SET
		[TOTAL_STEP_COUNT] = u.[TOTAL_STEP_COUNT]
	,	[TOTAL_STEP_DURATION] = u.[TOTAL_STEP_DURATION]
	,	[AVERAGE_STEP_DURATION]	= u.[AVERAGE_STEP_DURATION]	
	FROM [dbo].[JOB_STEP_AVERAGE_DURATION] d
	JOIN [dbo].[JOB_STEP_AVERAGE_DURATION_UPDATE] u
	ON u.[JOB_KEY] = d.[JOB_KEY] AND u.[step_id] = d.[step_id]

	-- insert new average durations
	INSERT [dbo].[JOB_STEP_AVERAGE_DURATION] (
		[JOB_KEY]					
	,	[step_id]					
	,	[TOTAL_STEP_COUNT]			
	,	[TOTAL_STEP_DURATION]		
	,	[AVERAGE_STEP_DURATION]		
	)

	SELECT
		u.[JOB_KEY]					
	,	u.[step_id]					
	,	u.[TOTAL_STEP_COUNT]			
	,	u.[TOTAL_STEP_DURATION]		
	,	u.[AVERAGE_STEP_DURATION]		
	FROM [dbo].[JOB_STEP_AVERAGE_DURATION_UPDATE] u
	LEFT JOIN [dbo].[JOB_STEP_AVERAGE_DURATION] d
	ON d.[JOB_KEY] = u.[JOB_KEY] AND d.[step_id] = u.[step_id]
	WHERE d.[JOB_KEY] IS NULL;
END
GO
PRINT N'Creating [dbo].[CLOSE_ETL_DIMENSION_LOG]...';


GO
CREATE PROCEDURE [dbo].[CLOSE_ETL_DIMENSION_LOG]
	@P_ETL_KEY	INT	
AS
BEGIN
	UPDATE [dbo].[ETL_DIMENSION_LOG]
	SET
		[END_DATE] = GETDATE()
	WHERE [ETL_KEY] = @P_ETL_KEY;
END
GO
PRINT N'Creating [dbo].[CLOSE_ETL_HISTORY_LOG]...';


GO
CREATE PROCEDURE [dbo].[CLOSE_ETL_HISTORY_LOG]
	@P_ETL_KEY	INT	= NULL
AS
BEGIN
	DECLARE
		@ETL_KEY	INT;

	IF @P_ETL_KEY IS NULL
	BEGIN
		SELECT
			@ETL_KEY = MAX([ETL_KEY])
		FROM [dbo].[ETL_HISTORY_LOG];
	END
	ELSE
	BEGIN
		 SET @ETL_KEY = @P_ETL_KEY;
	END

	UPDATE [dbo].[ETL_HISTORY_LOG]
	SET
		[END_DATE] = GETDATE()
	WHERE [ETL_KEY] = @ETL_KEY;
END
GO
PRINT N'Creating [dbo].[CREATE_ETL_DIMENSION_LOG]...';


GO
CREATE PROCEDURE [dbo].[CREATE_ETL_DIMENSION_LOG]
	@P_ETL_KEY	INT	OUTPUT
AS
BEGIN
	INSERT [dbo].[ETL_DIMENSION_LOG]
	DEFAULT VALUES;

	SET @P_ETL_KEY = SCOPE_IDENTITY();
END
GO
PRINT N'Creating [dbo].[CREATE_ETL_HISTORY_LOG]...';


GO
CREATE PROCEDURE [dbo].[CREATE_ETL_HISTORY_LOG]
	@P_ETL_KEY	INT	OUTPUT
AS
BEGIN
	/*

		Extract the rows from the msdb.dbo.sysjobhistory table beginning
		with the first row added after the last time the ETL was run
		and the current last row in the msdb.dbo.sysjobhistory table.

		USAGE:

		DECLARE @ETL_KEY	INT;

		EXEC [dbo].[CREATE_ETL_HISTORY_LOG]
			@P_ETL_KEY =  @ETL_KEY OUTPUT;

		SELECT @ETL_KEY;

	*/
	DECLARE
		@BEGIN_INSTANCE_ID	INT
	,	@END_INSTANCE_ID	INT;

	-- Get the starting instance_id for the msdb.dbo.sysjobhistory table
	-- It's the MAX([INSTANCE_ID]) from the JOB_INSTANCE table incremented
	-- by 1.
	SELECT
		@BEGIN_INSTANCE_ID = MAX([INSTANCE_ID]) + 1
	FROM [dbo].[JOB_INSTANCE];

	IF @BEGIN_INSTANCE_ID IS NULL
		SET @BEGIN_INSTANCE_ID = 0;

	-- Get the ending instance_id for the msdb.dbo.sysjobhistory table
	SELECT 
		@END_INSTANCE_ID = MAX([instance_id])
	FROM msdb.dbo.sysjobhistory
	WHERE [run_status] = 1;

	IF @END_INSTANCE_ID IS NULL
		SET @END_INSTANCE_ID = 0;

	INSERT [dbo].[ETL_HISTORY_LOG] (
		[BEGIN_INSTANCE_ID]
	,	[END_INSTANCE_ID]	
	)
	VALUES (
		COALESCE(@BEGIN_INSTANCE_ID, 0)
	,	COALESCE(@END_INSTANCE_ID, 0)
	);

	SET @P_ETL_KEY = SCOPE_IDENTITY();
END
GO
PRINT N'Creating [dbo].[GET_ACTIVE_JOBS]...';


GO
CREATE PROCEDURE [dbo].[GET_ACTIVE_JOBS]
AS
BEGIN
	DECLARE 
		@SQL_AGENT_IS_RUNNING	SMALLINT
	,	@SESSION_ID				INT
	,	@REFRESH_KEY			INT = NEXT VALUE FOR [dbo].[REFRESH_KEY]
	,	@REFRESH_DATE			SMALLDATETIME = CONVERT(SMALLDATETIME, GETDATE());

	SELECT 
		@SQL_AGENT_IS_RUNNING = IIF([status_desc] = 'Running', 1, 0)
	FROM sys.dm_server_services
	WHERE LEFT([servicename], 16) = 'SQL Server Agent';

	IF @SQL_AGENT_IS_RUNNING = 0
	BEGIN
		RAISERROR('The SQL Agent Service is not running.', 11, 1);
		RETURN;
	END

	SELECT
		@SESSION_ID = MAX(session_id)
	FROM msdb.dbo.syssessions;

	;WITH CTE_JOBS_RUNNING AS (
		SELECT
			c.[JOB_KEY]
		, 	a.[job_id]
		,	a.[start_execution_date]
		,	a.[last_executed_step_id]
		,	a.[last_executed_step_date]
		FROM msdb.dbo.sysjobactivity a
		LEFT JOIN [dbo].[JOB_EXCLUDE] x
		ON x.[job_id] = a.[job_id]
		LEFT JOIN [dbo].[JOB_CURRENT] c
		ON c.[job_id] = a.[job_id]
		WHERE a.session_id = @SESSION_ID
		AND a.start_execution_date IS NOT NULL
		AND stop_execution_date IS NULL
		AND x.[name] IS NULL
	)

	--
	--SELECT * FROM CTE_JOBS_RUNNING
	--

	, CTE_JOB_STEPS_REMAINING_DURATION AS (
		SELECT
		 	a.[JOB_KEY]
		,	SUM(d.[AVERAGE_STEP_DURATION]) [job_step_average_duration]
		FROM CTE_JOBS_RUNNING a
		LEFT JOIN [dbo].[JOB_STEP_AVERAGE_DURATION] d
		ON d.[JOB_KEY] = a.[JOB_KEY]
		WHERE d.[step_id] > COALESCE(a.[last_executed_step_id], 0)
		GROUP BY a.[JOB_KEY]
	)

	--
	--SELECT * FROM CTE_JOB_STEPS_REMAINING_DURATION
	--

	INSERT [dbo].[ACTIVE_JOBS] (
		[REFRESH_KEY]
	,	[job_id]
	,	[CURRENT_DURATION]
	,	[EXECUTION_COUNT]
	,	[AVERAGE_DURATION]
	,	[ESTIMATED_COMPLETION]
	)
	SELECT
		@REFRESH_KEY
	,	a.[job_id]	
	,	DATEDIFF(second, a.[start_execution_date], GETDATE())	AS [current_duration]
	,	0	-- TO DO: get the number of times the job has run?
	,	d.[job_step_average_duration]	-- based on last step executed
	,	CONVERT(
			SMALLDATETIME
		,
			DATEADD(
				second
			,	d.[job_step_average_duration] + DATEDIFF(second, a.[start_execution_date], GETDATE())
			, a.[start_execution_date]
			) 
		) AS [estimated_completion]
	FROM CTE_JOBS_RUNNING a
	LEFT JOIN CTE_JOB_STEPS_REMAINING_DURATION d
	ON d.[JOB_KEY] = a.[JOB_KEY];

	INSERT [dbo].[ACTIVE_JOBS_REFRESH] (
		[REFRESH_KEY]
	,	[REFRESH_DATE]
	)
	SELECT
	 	@REFRESH_KEY
	,	@REFRESH_DATE;
END
GO
PRINT N'Creating [dbo].[GET_ETL_DIMENSION_LOG]...';


GO
CREATE PROCEDURE [dbo].[GET_ETL_DIMENSION_LOG]
	@P_ETL_KEY	INT	OUTPUT
AS
BEGIN
	DECLARE @ETL_KEY	INT;

	SELECT TOP 1
		@ETL_KEY = [ETL_KEY]
	FROM [dbo].[ETL_DIMENSION_LOG]
	ORDER BY [ETL_KEY] DESC;

	IF @ETL_KEY IS NULL
	BEGIN
		EXEC [dbo].[CREATE_ETL_DIMENSION_LOG]
			@P_ETL_KEY = @ETL_KEY OUTPUT;	
	END

	SET @P_ETL_KEY = @ETL_KEY;
END
GO
PRINT N'Creating [dbo].[GET_ETL_HISTORY_LOG]...';


GO
CREATE PROCEDURE [dbo].[GET_ETL_HISTORY_LOG]
	@P_ETL_KEY				INT OUTPUT
,	@P_BEGIN_INSTANCE_ID	INT OUTPUT
,	@P_END_INSTANCE_ID		INT OUTPUT
AS
BEGIN
	/*
		Get the row created by the last execution of [dbo].[CREATE_ETL_HISTORY_LOG] which
		should be the first step in the SQL Agent job. 

		Steps following the first step that need the @ETL_KEY should call this procedure.

		USAGE:

		DECLARE 
			@ETL_KEY			INT
		,	@BEGIN_INSTANCE_ID	INT
		,	@END_INSTANCE_ID	INT;

		EXEC [dbo].[GET_ETL_HISTORY_LOG]
			@P_ETL_KEY = @ETL_KEY OUTPUT
		,	@P_BEGIN_INSTANCE_ID = @BEGIN_INSTANCE_ID	OUTPUT
		,	@P_END_INSTANCE_ID = @END_INSTANCE_ID		OUTPUT;

		SELECT 
			@ETL_KEY
		,	@BEGIN_INSTANCE_ID
		,	@END_INSTANCE_ID;

	*/
	DECLARE 
		@ETL_KEY	INT
	,	@BEGIN_INSTANCE_ID	INT
	,	@END_INSTANCE_ID	INT;

	SELECT 
		@ETL_KEY = MAX([ETL_KEY]) 
	FROM [dbo].[ETL_HISTORY_LOG];

	SELECT
		@BEGIN_INSTANCE_ID = [BEGIN_INSTANCE_ID]
	,	@END_INSTANCE_ID   = [END_INSTANCE_ID]
	FROM [dbo].[ETL_HISTORY_LOG]
	WHERE [ETL_KEY] = @ETL_KEY;

	SET @P_ETL_KEY = @ETL_KEY;
	SET @P_BEGIN_INSTANCE_ID = @BEGIN_INSTANCE_ID;
	SET @P_END_INSTANCE_ID = @END_INSTANCE_ID;
END
GO
PRINT N'Creating [dbo].[SimulateJobStepDuration]...';


GO
CREATE PROCEDURE [dbo].[SimulateJobStepDuration]
	@MINIMUM_MINUTES	INT = 1
,	@MAXIMUM_MINUTES	INT = 10
,	@RAISE_ERROR		BIT = 0
,	@DEBUG				BIT = 0
AS
BEGIN
	IF @RAISE_ERROR = 1
	BEGIN
		RAISERROR(N'ERROR OCCURRED IN SimulateJobStepDuration', 11, 1);
		RETURN;
	END

	-- convert to range of seconds
	DECLARE
	 	@MINIMUM_SECONDS		INT = @MINIMUM_MINUTES * 60
	,	@MAXIMUM_SECONDS		INT = @MAXIMUM_MINUTES * 60
	,	@STEP_DURATION_SECONDS	INT = 0
	,	@NOW					SMALLDATETIME = GETDATE()
	,	@WAIT_FOR				VARCHAR(10);

	WHILE @STEP_DURATION_SECONDS < @MINIMUM_SECONDS
	BEGIN
		SET @STEP_DURATION_SECONDS = FLOOR(RAND() * @MAXIMUM_SECONDS);
	END

	-- hh, mi, ss
	DECLARE
		@WAIT_UNTIL	SMALLDATETIME = DATEADD(second, @STEP_DURATION_SECONDS, @NOW);
	DECLARE
		@HOURS		SMALLINT = DATEPART(hh, @WAIT_UNTIL)
	,	@MINUTES 	SMALLINT = DATEPART(mi, @WAIT_UNTIL)
	,	@SECONDS	SMALLINT = DATEPART(ss, @WAIT_UNTIL);

	DECLARE
		@WAITFOR_STRING		CHAR(58) = 
			RIGHT('00' + CONVERT(VARCHAR(2), @HOURS), 2) +
			':' +
			RIGHT('00' + CONVERT(VARCHAR(2), @MINUTES), 2) +
			':' +
			RIGHT('00' + CONVERT(VARCHAR(2), @SECONDS), 2);

	IF @DEBUG = 1
	BEGIN
		SELECT 
			@MINIMUM_MINUTES		AS [MINIMUM_MINUTES]
		,	@MINIMUM_SECONDS		AS [MINIMUM_SECONDS]
		,	@MAXIMUM_MINUTES		AS [MAXIMUM_MINUTES]
		,	@MAXIMUM_SECONDS		AS [MAXIMUM_SECONDS]
		,	@STEP_DURATION_SECONDS	AS [STEP_DURATION_SECONDS]
		,	@WAITFOR_STRING			AS [WAITFOR_STRING];
	END

	IF @DEBUG = 0
	BEGIN
		WAITFOR TIME @WAITFOR_STRING;
	END
END
GO
PRINT N'Creating [dbo].[UPDATE_JOB_CURRENT]...';


GO
CREATE PROCEDURE [dbo].[UPDATE_JOB_CURRENT]
AS
BEGIN
	/*

		INSERT any new jobs into the [dbo].[JOB_CURRENT] table.

	*/
	-- Get the "current" row for each job
	;WITH CTE_JOB_VERSION AS (
		SELECT
			[JOB_KEY]
		,	[job_id]
		,	ROW_NUMBER() OVER (
				PARTITION BY [job_id]
				ORDER BY [job_id], [date_modified] DESC
			) AS [ROW_NUMBER]
		FROM [dbo].[sysjobs]
	)
	, CTE_CURRENT_JOB AS (
		SELECT
			[JOB_KEY]
		,	[job_id]
		FROM CTE_JOB_VERSION
		WHERE [ROW_NUMBER] = 1
	)
	, CTE_JOB_STEP_COUNT AS (
		SELECT
			s.[JOB_KEY]
		,	COUNT(*)	AS [JOB_STEP_COUNT]
		FROM [dbo].[sysjobsteps] s
		JOIN CTE_CURRENT_JOB c
		ON c.[JOB_KEY] = s.[JOB_KEY]
		GROUP BY s.[JOB_KEY]
	)

	INSERT [dbo].[JOB_CURRENT] (
		[JOB_KEY]
	,	[job_id]
	,	[JOB_STEP_COUNT]
	)
	SELECT
		j.[JOB_KEY]
	,	j.[job_id]
	,	ISNULL(n.[JOB_STEP_COUNT], 0)
	FROM  CTE_CURRENT_JOB j
	LEFT JOIN CTE_JOB_STEP_COUNT n
	ON n.JOB_KEY = j.JOB_KEY
	LEFT JOIN [dbo].[JOB_CURRENT] c
	ON c.[JOB_KEY] = j.[JOB_KEY]
	WHERE c.[JOB_KEY] IS NULL;

	-- remove rows that are no longer current
	;WITH CTE_OLD_JOBS AS (
		SELECT
			[JOB_KEY]
		,	[job_id]
		,	ROW_NUMBER() OVER (
				PARTITION BY [job_id]
				ORDER BY [job_id], [JOB_KEY] DESC
			) AS [ROW_NUMBER]
		FROM [dbo].[JOB_CURRENT]
	)

	DELETE c
	FROM [dbo].[JOB_CURRENT] c
	JOIN CTE_OLD_JOBS x
	ON x.[JOB_KEY] = c.[JOB_KEY]
	WHERE x.[ROW_NUMBER] > 1;
END
GO
PRINT N'Creating [dbo].[UPDATE_JOB_INSTANCE]...';


GO
CREATE PROCEDURE [dbo].[UPDATE_JOB_INSTANCE]
AS
BEGIN
	/*
		Incremental load of JOB_INSTANCE table from [staging].[sysjobhistory]. INSERT new rows where
		the JOB_KEY does not exist in the JOB_INSTANCE table.

	*/

	INSERT [dbo].[JOB_INSTANCE] (
	  [JOB_KEY]
	, [INSTANCE_ID]
	, [job_id]
	, [step_id]
	, [step_name]
	, [sql_message_id]
	, [sql_severity]
	, [message]
	, [run_status]
	, [run_date]
	, [run_time]
	, [run_duration]
	, [operator_id_emailed]
	, [operator_id_netsent]
	, [operator_id_paged]
	, [retries_attempted]
	, [server]
	, [start_time]
	, [end_time]
	, [duration_seconds]
	, [ETL_KEY]	
	, [STAGING_KEY]	
	)
	SELECT
		c.JOB_KEY  
	,	[instance_id]
	, h.[job_id]
	, [step_id]
	, [step_name]
	, [sql_message_id]
	, [sql_severity]
	, [message]
	, [run_status]
	, [run_date]
	, [run_time]
	, [run_duration]
	, [operator_id_emailed]
	, [operator_id_netsent]
	, [operator_id_paged]
	, [retries_attempted]
	, [server]
	, [start_time]
	, [end_time]
	, [duration_seconds]
	, [ETL_KEY]
	, [STAGING_KEY]
	FROM [staging].[sysjobhistory] h
	JOIN [dbo].[JOB_CURRENT] c
	ON c.[job_id] = h.[job_id]
	LEFT JOIN [dbo].[JOB_EXCLUDE] x
	ON x.[job_id] = h.[job_id]
	WHERE h.[step_id] = 0				-- only get job outcome rows
	AND x.[name] IS NULL;
END
GO
PRINT N'Creating [dbo].[UPDATE_JOB_INSTANCE_ALL_STEPS_COMPLETED]...';


GO
CREATE PROCEDURE [dbo].[UPDATE_JOB_INSTANCE_ALL_STEPS_COMPLETED]
	@BEGIN_JOB_INSTANCE INT
,	@END_JOB_INSTANCE	INT
AS
BEGIN
	/*

		Determine the unique COUNT of job steps completed for the JOB_INSTANCE values in
		the range of @BEGIN_JOB_INSTANCE and @END_JOB_INSTANCE parameter values.

		If a job step is executed more than one (e.g. failed one or more times, retried one or more
		times, etc.) only count the step once.

		INSERT rows into  [dbo].[JOB_INSTANCE_ALL_STEPS_COMPLETED] where the steps completed in
		the job instance equals the number of steps in the job.

		We want to exclude job instances where not all steps were completed becuase it would
		skew the average duration calculation.

	*/

	-- Get the count job steps completed
	; WITH CTE_JOB_STEPS_COMPLETED AS (
		SELECT
		 	[JOB_INSTANCE_ID]
		,	[JOB_KEY]
		,	COUNT(*)	AS [STEPS_COMPLETED]
		FROM [dbo].[JOB_STEP_INSTANCE] j
		WHERE [JOB_INSTANCE_ID] BETWEEN @BEGIN_JOB_INSTANCE AND @END_JOB_INSTANCE
		GROUP BY [JOB_INSTANCE_ID], [JOB_KEY] 	
	)

	, CTE_DISTINCT_JOBS AS (
		SELECT DISTINCT
			[JOB_KEY]
		FROM CTE_JOB_STEPS_COMPLETED 
	)

	-- Get the count of job steps for these jobs
	, CTE_JOB_STEPS_COUNT AS (
		SELECT
			s.[JOB_KEY]
		,	COUNT(*)	AS [STEP_COUNT]
		FROM [dbo].[sysjobsteps] s
		JOIN CTE_DISTINCT_JOBS j 
		ON j.[JOB_KEY] = s.[JOB_KEY]
		GROUP BY s.[JOB_KEY]
	)

	INSERT [dbo].[JOB_INSTANCE_ALL_STEPS_COMPLETED] (
		[JOB_KEY]
	,	[INSTANCE_ID]
	)	
	SELECT
	 	c.[JOB_KEY]
	,	c.[JOB_INSTANCE_ID]
	FROM CTE_JOB_STEPS_COMPLETED c
	JOIN CTE_JOB_STEPS_COUNT s
	ON s.[JOB_KEY] = c.[JOB_KEY]
	WHERE c.[STEPS_COMPLETED] = s.[STEP_COUNT];
END
GO
PRINT N'Creating [dbo].[UPDATE_JOB_STEP_INSTANCE]...';


GO
CREATE PROCEDURE [dbo].[UPDATE_JOB_STEP_INSTANCE]
AS
BEGIN
	/*
		Incremental load of JOB_STEP_INSTANCE table from [staging].[sysjobhistory]. INSERT new rows where
		the JOB_KEY does not exist in the JOB_INSTANCE table.

	*/

	INSERT [dbo].[JOB_STEP_INSTANCE] (
	  [JOB_KEY]
	, [JOB_INSTANCE_ID]
	, [JOB_STEP_INSTANCE_ID]
	, [job_id]
	, [step_id]
	, [step_name]
	, [sql_message_id]
	, [sql_severity]
	, [message]
	, [run_status]
	, [run_date]
	, [run_time]
	, [run_duration]
	, [operator_id_emailed]
	, [operator_id_netsent]
	, [operator_id_paged]
	, [retries_attempted]
	, [server]
	, [start_time]
	, [end_time]
	, [duration_seconds]
	, [ETL_KEY]	
	, [STAGING_KEY]	
	)
	SELECT
		c.JOB_KEY  
	,	j.[INSTANCE_ID]	-- JOB_INSTANCE
	,	h.[instance_id]	-- JOB_STEP_INSTANCE_ID
	, h.[job_id]
	, h.[step_id]
	, h.[step_name]
	, h.[sql_message_id]
	, h.[sql_severity]
	, h.[message]
	, h.[run_status]
	, h.[run_date]
	, h.[run_time]
	, h.[run_duration]
	, h.[operator_id_emailed]
	, h.[operator_id_netsent]
	, h.[operator_id_paged]
	, h.[retries_attempted]
	, h.[server]
	, h.[start_time]
	, h.[end_time]
	, h.[duration_seconds]
	, h.[ETL_KEY]
	, h.[STAGING_KEY]
	FROM [staging].[sysjobhistory] h
	JOIN [dbo].[JOB_CURRENT] c
	ON c.[job_id] = h.[job_id]
	JOIN [dbo].[JOB_INSTANCE] j
	ON j.[JOB_KEY] = c.[JOB_KEY]
	LEFT JOIN [dbo].[JOB_EXCLUDE] x
	ON x.[job_id] = h.[job_id]
		-- only get job step outcome rows
	WHERE h.[step_id] > 0			
		-- get JOB_INSTANCE based on range of start_time and end_time
	AND h.[start_time] BETWEEN j.[start_time] AND j.[end_time]
	AND x.[name] IS NULL;				
END
GO
PRINT N'Creating [dbo].[UPDATE_sysjobs]...';


GO
CREATE PROCEDURE [dbo].[UPDATE_sysjobs]
AS
BEGIN
	/*

		UPDATE_sysjobs
		
		sysjobs is implemented as a type 2 slowly changing dimension. The [staging].[sysjobs_UPDATE] 
		table has the details on the new or updated sysjobs rows in the [staging].[sysjobs] table.

		A new row is added to sysjobs for any row in staging that represents a new job or an updated job.

		To make sure that this stored procedure can be rerun without error, if a row exists in sysjobs
		where the JOB_KEY matches the NEW_JOB_KEY in the [staging].[sysjobs_UPDATE] table, the row will
		be skipped. This covers the edge case where an error occurs in the UPDATE-SQL-AGENT-Dimensions
		SSIS package, it gets rerun, but this stored procedure completed successfully during the prior
		run where the error was raised.
	*/

	-- INSERT new rows into sysjobs whether we determined an INSERT or an UPDATE
	INSERT [dbo].[sysjobs] (
	  [JOB_KEY]
	, [job_id]
	, [originating_server_id]
	, [name]
	, [enabled]
	, [description]
	, [start_step_id]
	, [category_id]
	, [owner_sid]
	, [notify_level_eventlog]
	, [notify_level_email]
	, [notify_level_netsend]
	, [notify_level_page]
	, [notify_email_operator_id]
	, [notify_netsend_operator_id]
	, [notify_page_operator_id]
	, [delete_level]
	, [date_created]
	, [date_modified]
	, [version_number]
	, [ETL_KEY]
	, [STAGING_KEY]
	)
	SELECT
	  u.[NEW_JOB_KEY]
	, j.[job_id]
	, j.[originating_server_id]
	, j.[name]
	, j.[enabled]
	, j.[description]
	, j.[start_step_id]
	, j.[category_id]
	, j.[owner_sid]
	, j.[notify_level_eventlog]
	, j.[notify_level_email]
	, j.[notify_level_netsend]
	, j.[notify_level_page]
	, j.[notify_email_operator_id]
	, j.[notify_netsend_operator_id]
	, j.[notify_page_operator_id]
	, j.[delete_level]
	, j.[date_created]
	, j.[date_modified]
	, j.[version_number]
	, j.[ETL_KEY]
	, j.[STAGING_KEY]	
	FROM [staging].[sysjobs_UPDATE] u
	JOIN [staging].[sysjobs] j
	ON j.[job_id] = u.[job_id]
	LEFT JOIN [dbo].[sysjobs] d
	ON d.[JOB_KEY] = u.[NEW_JOB_KEY]
	WHERE d.JOB_KEY IS NULL;
END
GO
PRINT N'Creating [dbo].[UPDATE_sysjobs_AND_sysjobsteps]...';


GO
CREATE PROCEDURE [dbo].[UPDATE_sysjobs_AND_sysjobsteps]
AS
BEGIN
	/*

		This procedure is no longer used. It has been split into 2 procedures:
		UPDATE_sysjobs and UPDATE_sysjobsteps.

	*/
	
	RAISERROR (
		N'THe stored procedure UPDATE_sysjobs_AND_sysjobsteps is DEPRECATED'
	,   10
	,	1
	);
	
	/*
	-- INSERT new rows into sysjobs whether we determined an INSERT or an UPDATE
	INSERT [dbo].[sysjobs] (
	  [JOB_KEY]
	, [job_id]
	, [originating_server_id]
	, [name]
	, [enabled]
	, [description]
	, [start_step_id]
	, [category_id]
	, [owner_sid]
	, [notify_level_eventlog]
	, [notify_level_email]
	, [notify_level_netsend]
	, [notify_level_page]
	, [notify_email_operator_id]
	, [notify_netsend_operator_id]
	, [notify_page_operator_id]
	, [delete_level]
	, [date_created]
	, [date_modified]
	, [version_number]
	, [ETL_KEY]
	, [STAGING_KEY]
	)
	SELECT
	  u.[NEW_JOB_KEY]
	, j.[job_id]
	, j.[originating_server_id]
	, j.[name]
	, j.[enabled]
	, j.[description]
	, j.[start_step_id]
	, j.[category_id]
	, j.[owner_sid]
	, j.[notify_level_eventlog]
	, j.[notify_level_email]
	, j.[notify_level_netsend]
	, j.[notify_level_page]
	, j.[notify_email_operator_id]
	, j.[notify_netsend_operator_id]
	, j.[notify_page_operator_id]
	, j.[delete_level]
	, j.[date_created]
	, j.[date_modified]
	, j.[version_number]
	, j.[ETL_KEY]
	, j.[STAGING_KEY]	
	FROM [staging].[sysjobs_UPDATE] u
	JOIN [staging].[sysjobs] j
	ON j.[job_id] = u.[job_id];

	-- INSERT new rows into sysjobsteps
	INSERT [dbo].[sysjobsteps] (
		[JOB_KEY]
	, [job_id]
	, [step_id]
	, [step_name]
	, [subsystem]
	, [command]
	, [flags]
	, [additional_parameters]
	, [cmdexec_success_code]
	, [on_success_action]
	, [on_success_step_id]
	, [on_fail_action]
	, [on_fail_step_id]
	, [server]
	, [database_name]
	, [database_user_name]
	, [retry_attempts]
	, [retry_interval]
	, [os_run_priority]
	, [output_file_name]
	, [last_run_outcome]
	, [last_run_duration]
	, [last_run_retries]
	, [last_run_date]
	, [last_run_time]
	, [proxy_id]
	, [step_uid]	
	, [ETL_KEY]
	, [STAGING_KEY]	
	)
	SELECT
	  u.[NEW_JOB_KEY]
	, s.[job_id]
	, [step_id]
	, [step_name]
	, [subsystem]
	, [command]
	, [flags]
	, [additional_parameters]
	, [cmdexec_success_code]
	, [on_success_action]
	, [on_success_step_id]
	, [on_fail_action]
	, [on_fail_step_id]
	, [server]
	, [database_name]
	, [database_user_name]
	, [retry_attempts]
	, [retry_interval]
	, [os_run_priority]
	, [output_file_name]
	, [last_run_outcome]
	, [last_run_duration]
	, [last_run_retries]
	, [last_run_date]
	, [last_run_time]
	, [proxy_id]
	, [step_uid]	
	, s.[ETL_KEY]
	, s.[STAGING_KEY]	
	FROM [staging].[sysjobs_UPDATE] u
	JOIN [staging].[sysjobsteps] s
	ON s.[job_id] = u.[job_id];
*/
END
GO
PRINT N'Creating [dbo].[UPDATE_sysjobsteps]...';


GO
CREATE PROCEDURE [dbo].[UPDATE_sysjobsteps]
AS
BEGIN
	/*
		UPDATE_sysjobsteps
		
		sysjobsteps is implemented as a type 2 slowly changing dimension. However, to determine what changed,
		we rely solely on the current sysjobs row. The details of new or changed sysjobs is recorded in the
		[staging].[sysjobs_UPDATE] table.

		The [staging].[sysjobsteps] table is used to determine the rows to add to the sysjobsteps table. All rows are 
		extracted from the msdb sysjobsteps table in order to make this work. Whether any sysjobstep row actually
		changed is ignored; all rows from staging are added with the NEW_JOB_KEY.

		To make sure that this stored procedure can be rerun without error, if a row exists in sysjobsteps
		where the JOB_KEY matches the NEW_JOB_KEY in the [staging].[sysjobs_UPDATE] table and the [step_id] matches, 
		the row will be skipped. This covers the edge case where an error occurs in the UPDATE-SQL-AGENT-Dimensions
		SSIS package, it gets rerun, but this stored procedure completed successfully during the prior
		run where the error was raised.
	*/
	INSERT [dbo].[sysjobsteps] (
	  [JOB_KEY]
	, [job_id]
	, [step_id]
	, [step_name]
	, [subsystem]
	, [command]
	, [flags]
	, [additional_parameters]
	, [cmdexec_success_code]
	, [on_success_action]
	, [on_success_step_id]
	, [on_fail_action]
	, [on_fail_step_id]
	, [server]
	, [database_name]
	, [database_user_name]
	, [retry_attempts]
	, [retry_interval]
	, [os_run_priority]
	, [output_file_name]
	, [last_run_outcome]
	, [last_run_duration]
	, [last_run_retries]
	, [last_run_date]
	, [last_run_time]
	, [proxy_id]
	, [step_uid]	
	, [ETL_KEY]
	, [STAGING_KEY]	
	)
	SELECT
	  u.[NEW_JOB_KEY]
	, s.[job_id]
	, s.[step_id]
	, s.[step_name]
	, s.[subsystem]
	, s.[command]
	, s.[flags]
	, s.[additional_parameters]
	, s.[cmdexec_success_code]
	, s.[on_success_action]
	, s.[on_success_step_id]
	, s.[on_fail_action]
	, s.[on_fail_step_id]
	, s.[server]
	, s.[database_name]
	, s.[database_user_name]
	, s.[retry_attempts]
	, s.[retry_interval]
	, s.[os_run_priority]
	, s.[output_file_name]
	, s.[last_run_outcome]
	, s.[last_run_duration]
	, s.[last_run_retries]
	, s.[last_run_date]
	, s.[last_run_time]
	, s.[proxy_id]
	, s.[step_uid]	
	, s.[ETL_KEY]
	, s.[STAGING_KEY]	
	FROM [staging].[sysjobs_UPDATE] u
	JOIN [staging].[sysjobsteps] s
	ON s.[job_id] = u.[job_id]
	LEFT JOIN [dbo].[sysjobsteps] d
	ON d.[JOB_KEY] = u.[NEW_JOB_KEY] AND d.[step_id] = s.[step_id]
	WHERE d.[JOB_KEY] IS NULL;
END
GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [staging].[sysjobs_UPDATE] WITH CHECK CHECK CONSTRAINT [CK_sysjobs_UPDATE_ACTION];


GO
PRINT N'Update complete.';


GO
